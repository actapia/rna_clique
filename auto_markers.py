import math
import functools
import operator

from itertools import cycle, count
from functools import reduce
from typing import Any, Optional, TypeVar, Callable, Iterator
from collections.abc import Hashable, Iterable

from plots import as_tuple

import matplotlib as mpl
import pandas as pd

from glasbeyish import glasbey
from nice_colorsys import rgb

# @dataclass
# class AutoMarkerStyle:
#     color: rgb255
#     shape: str
#     filled: bool

#     def to_scatter_kwargs(self):
#         pass

def style_to_scatter_kwargs(
        color: int | tuple[float, float, float] | rgb  = "c1",
        shape: str = "o",
        fill: bool = True
) -> dict[str, Any]:
    """Construct matplotlib scatter kwargs for given marker style description.

    Parameters:
        color (int): The color of the marker.
        shape (str): The shape of the marker.
        fill (bool): Whether the marker is filled.
    """
    kwargs = {"marker": shape, "color": color}
    if not fill:
        kwargs["facecolors"] = "none"
    return kwargs
       
shapes = ["o", "^", "s", "*", "v", "D", "<", ">", "x", "2", "1", "3", "4"]

H = TypeVar("H", bound=Hashable)

def ncolor_assigner(
        n: Optional[int] = None,
        prefer_mpl: bool = True,
        seed: int = 485
) -> Callable[[Iterable[H]], dict[H, rgb]]:
    """Get a function that assigns colors to hashable objects.

    The parameter n can optionally be provided to limit the number of colors
    that can be used. If the parameter provided to the returned function has
    more than n distinct values, then colors will be reused.

    Note that when n >= 12, some colors are likely to be very similar. In that
    case, it is recommended to use other visual variables in conjunction with
    color to encode your data.

    By default, the colors assigned come from matplotlib's tab10 colorset. If n
    > 10, or if prefer_mpl is False, then a set of maximally distinct colors is
    approximated using the glasbeyish library instead. The color palette
    generated by the glasbeyish library are (pseudo-)random. A seed may be
    provided to ensure consistency across runs.

    Parameters:
        n (int):           The number of colors to use in the assignment.
        prefer_mpl (bool): Whether to use matplotlib or glasbeyish for n <= 10.
        seed (int):        The seed to the PRNG use for glasbeyish.

    Returns:
        A function that assigns data to colors.
    """
    def color_assigner(data: Iterable[H]) -> dict[H, rgb]:
        if n is None:
            nn = data.shape[0]
        else:
            nn = n
        if nn <= 10 and prefer_mpl:
            return dict(zip(data, cycle(mpl.colormaps["tab10"].colors[:nn])))
        else:
            return dict(
                zip(
                    data,
                    cycle(
                        [c.to_rgb().safe() for c in glasbey(n, seed=seed)]
                    )
                )
            )
    return color_assigner

def pool_assigner[T](pool: Iterable[T]) -> Callable[[Iterable[H]], dict[H, T]]:
    """Return a function that assigns values to hashable objects from a pool.

    If values must be assigned for more distinct objects than are in the pool,
    then values from the pool will be reused.

    Parameters:
        pool: The collection from which to draw values for assignment.

    Returns:
        A function that assigns data to values from the pool.
    """
    def assigner(data: Iterable[H]) -> dict[H, T]:
        return dict(zip(data, cycle(pool)))
    return assigner

def nshape_assigner(
        n: Optional[int] = None
) -> Callable[[Iterable[H]], dict[H, str]]:
    """Get a function that assigns matplotlib marker shapes to hashable objects.

    The parameter n can optionally be provided to limit the number of shapes
    that can be used. If n is not provided or is greater than len(shapes), then
    n is taken to be len(shapes), 13.

    If the parameter provided to the returned function has more than n distinct
    hashable objects, then shapes will be reused.

    Parameters:
        n (int): The number of shapes to use in assignments.

    Returns:
        A function that assigns marker shapes to objects.
    """
    if n is None:
        n = len(shapes)
    return pool_assigner(shapes[:n])

default_color_assigner = ncolor_assigner()
default_fill_assigner = pool_assigner([True, False])
default_shape_assigner = nshape_assigner()

# def auto_assign_markers(
#         data: pd.DataFrame,
#         assigners: dict[str, Callable] = {
#             "color": default_color_assigner,
#             "shape": default_shape_assigner,
# #            "fill": default_fill_assigner
#         }
# ) -> dict[Any, dict[str, Any]]:
#     column_order = [
#         c[1]
#         for c in sorted(
#                 (
#                     (s.value_counts().shape[0], n) for (n, s) in data.items()
#                 ),
#                 reverse=True,
#         )
#     ]
#     styles = {
#         style: assigner(data[name].value_counts().index) for
#         (name, (style, assigner)) in zip(
#             cycle(column_order),
#             assigners.items()
#         )
#     }


def assign_markers(
        data: pd.DataFrame,
        encodings: dict[str | tuple[str], str | Iterable[str]],
        assigners: dict[str, Callable]  = {
            "color": default_color_assigner,
            "shape": default_shape_assigner,
            "fill": default_fill_assigner,
        }
) -> dict[Any, dict[str, Any]]:
    """Automatically encode distinct values using the provided assigners.

    The first argument the function, data, must contain only the relevant
    columns of the data. Every distinct row in the provided dataframe will be
    mapped to a set of kwargs to use for matplotlib's scatter function.

    This functions requires that the visual variables to use for encoding
    columns in the dataframe be provided explicitly. For example,

        encodings={"column_a": "color", "column_b": "shape"}

    encodes different values for column_a using color and different values for
    column_b using shape. In this case (the simplest case), each key is a single
    column, and each value is a single visual variable.

    When a key is a tuple of multiple columns, then every distinct value for
    those columns is mapped to a (usually) different value for the visual
    variable(s) specified.

    When a value is a tuple of multiple visual variables, then every distinct
    value for the specified column(s) is simultaneously mapped to a (usually)
    different value for each of the specified visual variables.

    The assigners dict determines how different values for the data get mapped
    to different values for a given visual variable. The keys of the dict are
    the names of the visual variables for the scatter plot markers, which
    correspond to keyword arguments of the style_to_scatter_kwargs
    function. Note that these arguments are distinct from the variables used for
    matplotlib's scatter function. The style_to_scatter_kwargs function is used
    to convert between this code's custom representation of marker style and the
    kwargs used by matplotlib.

    Each value in the assigner dict is a function that takes an iterable of
    tuples for the columns of the data being assigned and returns a dict mapping
    each tuple to a (usually, but not necessarily distinct) value for the visual
    variable.

    Some assigners are already specified by default; the author of this code
    believes they should be useful and won't need to be changed in most
    circumstances.

    The recognized keys in the assigner dict (i.e., the valid keyword arguments
    for style_to_scatter kwargs) are:

        color: The color of the marker.
        shape: The shape of the marker.
        fill:  Whether the marker is filled.

    Parameters:
        data:             Data to encode visually.
        encodings (dict): Map from columns to visual variables.
        assigners (dict): Map from visual variables to value assigners.

    Returns:
        A dictionary mapping distinct data values to scatter kwargs.
    """
    encodings = {
        as_tuple(k): as_tuple(v)
        for (k, v) in encodings.items()
    }
    styles = {
        c: {
            k: assigners[k](data[list(c)].value_counts().index)
            for k in e
        }
        for (c, e) in encodings.items()
    }
    column_index = dict(map(reversed, enumerate(data.columns)))
    res = {}
    for key in data.value_counts().index:
        r = {}
        for c, d in styles.items():
            k = tuple(key[column_index[z]] for z in c)
            for a, b in d.items():
                r[a] = b[k]
        res[key] = style_to_scatter_kwargs(**r)
    return res

def pars_seq(a: int = 3, b: int = 2) -> Iterator[tuple[int, int]]:
    """Yields a sequence of coprime integer pairs, ordered by product.

    The sequence, p, is defined as follows:
    
    The first element,  p_0 = (3, 2).
    
    If p_n = (a, b), then p_(n+1) is the pair (c, d), c > d, minimizing
    max(c, d) such that (c, d) are coprime and c * d > a * b.

    This function starts yielding elements in the sequence beginning with
    (a, b), which is assumed to be a member of sequence p.

    Parameters:
        a (int): The first element of the pair to start the sequence.
        b (int): The second element of the pair to start the sequence.
    """
    while True:
        yield a, b
        if a % 2:
            if b < a - 1:
                b += 1
            else:
                a += 1
                b += 1
        else:
            a += 1

def pars2(n: int) -> tuple[int, int]:
    """Get the smallest element of the pars_seq sequence with product >= n."""
    sqrt = int(n**(1/2))
    for a, b in pars_seq(sqrt + 1, sqrt):
        if a * b >= n:
            return (a, b)

def naive_pars_seq(start: tuple) -> Iterator[tuple]:
    """Yields a sequence of pairwise coprime integer tuples, ordered by product.

    This is a generalization of the sequence in pars_seq to tuples of size
    m. However, my method obtaining the next element of the sequence for m > 2
    is less efficient than my method for m = 2. Whether there is a better method
    is unknown to the author of this code.

    The sequence, p_m, is defined as follows:

    The first element, p_m(0), is the decreasing tuple of m pairwise coprime
    integers, each greater than 1, that is minimal in lexicographic order.

    Element p_m(n + 1) is the decreasing tuple of m pairwise coprime integers,
    each greater than 1, with product greater than that of p_m(n), that is
    minimal in lexicographic order.

    Parameters:
        start (tuple): The tuple at which start yielding the sequence.
    """
    nums = list(reversed(start))
    pos = 0
    while True:
        #print("pos is",pos)
        if pos + 1 == len(nums):
            pos
            nums[pos] += 1
            pos -= 1
        else:
            #print("A")
            f = nums[pos + 1]
            #print("range",nums[pos]+1, nums[pos + 1])
            flag = False
            for f in range(nums[pos] + 1, nums[pos + 1]):
                #print(f,"for",pos)
                #print(nums)
                for g in nums[pos + 1:]:
                    if math.gcd(f, g) != 1:
                        break
                if math.gcd(f, g) == 1:
                    #print(f,"is good")
                    break
            else:
                nums[pos] = 1
                pos += 1
                flag = True
                continue
            if not flag:
                nums[pos] = f
                if pos == 0:
                    yield tuple(reversed(nums))
                else:
                    #print("Decrease pos.")
                    pos -= 1
        #input()
            
prod = functools.partial(reduce, operator.mul)
        
def naive_pars(n: int, m: int) -> tuple:
    """Get the first element of naive_pars_seq with m elements and product >= n.

    This uses the naive_pars_seq generator directly.

    Parameters:
        n (int): A natural number.
        m (int): The length of the tuple.

    Returns:
        A tuple of length m in naive_pars_seq with product >= n. 
    """
    root = int(n**(1/m))
    for t in naive_pars_seq([root + 1] + [1]*(m-1)):
        if prod(t) >= n:
            return t

# TODO: Account for maximum numbers of elements.

def pars(n, m):
    """Get the first element of naive_pars_seq with m elements and product >= n.

    This uses naiv_pars_seq for m > 2. For m = 2, the faster pars_seq is used
    instead.

    Parameters:
        n (int): A natural number.
        m (int): The length of the tuple.

    Returns:
        A tuple of length m in naive_pars_seq with product >= n. 

    """
    if m == 1:
        return (n,)
    if m == 2:
        return pars2(n)
    else:
        return naive_pars(n, m)

pars_assigners = {"color": ncolor_assigner, "shape": nshape_assigner}

def parsimonious_markers(
        data: pd.DataFrame,
        encodings: dict[str | tuple[str], str | Iterable[str]],
        assigners: dict[str, Callable] = {"fill": default_fill_assigner}
) -> dict[Any, dict[str, Any]]:
    """Automatically encode distinct values with few colors and shapes.

    This function select c colors and s shapes to cycle through such that
    at there are at least as many pairs of shapes possible as there are distinct
    values.

    Assigners can also be manually specified as in assign_markers.

    Parameters:
        data:             Data to encode visually using few colors and shapes.
        encodings:        Map from columns to visual variables.
        assigners (dict): Map from visual variables to value assigners.

    Returns:
        A dictionary efficiently mapping distinct data values to scatter kwargs.
    """
    encodings = {
        as_tuple(k): as_tuple(v)
        for (k, v) in encodings.items()
    }
    for vars_, encs in encodings.items():
        available = [e for e in encs if e in pars_assigners]
        dims = pars(
            data[list(vars_)].value_counts().index.shape[0],
            len(available)
        )
        print(dims)
        for dim, enc in zip(dims, available):
            assigners[enc] = pars_assigners[enc](dim)
    return assign_markers(data, encodings, assigners)
        
        
